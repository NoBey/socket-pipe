// Generated by CoffeeScript 1.12.2
(function() {
  var Event, Http, Net, ProxyStream, UUID, endSocket;

  Net = require('net');

  Event = require('events');

  Http = require('http');

  UUID = require('node-uuid');

  ProxyStream = require('./stream/proxy');

  endSocket = function(socket) {
    socket.resume();
    return socket.end("HTTP/1.1 404 Not Found\r\nContent-Type: text/html;charset=UTF-8\r\n\r\nNotFound");
  };

  module.exports = (function() {
    function _Class(localAddress, remoteAddress) {
      this.localAddress = localAddress;
      this.remoteAddress = remoteAddress;
      this.id = 0;
      this.dataEvent = new Event;
      this.daemonSockets = {};
      this.sockets = {};
      this.pipes = {};
      this.waits = {};
      setInterval((function(_this) {
        return function() {
          var buff, hash, item, now, ref, results, time, uuid;
          now = Date.now();
          ref = _this.waits;
          results = [];
          for (uuid in ref) {
            item = ref[uuid];
            hash = item[0], buff = item[1], time = item[2];
            if (now - time >= 1000) {
              item[2] = now;
              if ((_this.pipes[uuid] == null) && (_this.sockets[uuid] != null) && (_this.daemonSockets[hash] != null)) {
                _this.daemonSockets[hash][0].write(buff);
                results.push(console.info("retry pipe " + uuid));
              } else {
                results.push(void 0);
              }
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
      })(this), 200);
      this.dataEvent.on('accept', (function(_this) {
        return function(uuid) {
          var input;
          if (_this.sockets[uuid] == null) {
            return;
          }
          input = new ProxyStream;
          _this.sockets[uuid].push(input);
          input.setCallback(function(reqHost, head) {
            var buff, hash, host, output, regex;
            console.info("request " + reqHost);
            hash = reqHost.split('.')[0];
            if (_this.daemonSockets[hash] == null) {
              return endSocket(_this.sockets[uuid][0]);
            }
            host = _this.daemonSockets[hash][1] != null ? _this.daemonSockets[hash][1] : reqHost;
            buff = new Buffer(4);
            buff.writeInt32LE(uuid);
            console.info("request pipe " + uuid);
            _this.daemonSockets[hash][0].write(buff);
            _this.waits[uuid] = [hash, buff, Date.now()];
            regex = new RegExp(pregQuote(reqHost), 'ig');
            output = new ProxyStream;
            output.setFrom(host);
            output.setTo(reqHost);
            _this.sockets[uuid].push(output);
            _this.sockets[uuid][0].pause();
            return head.replace(regex, host);
          });
          _this.sockets[uuid][0].pipe(input);
          return _this.sockets[uuid][0].resume();
        };
      })(this));
      this.dataEvent.on('pipe', (function(_this) {
        return function(uuid, hash) {
          delete _this.waits[uuid];
          if (!_this.sockets[uuid]) {
            return;
          }
          if (!_this.daemonSockets[hash]) {
            return endSocket(_this.sockets[uuid]);
          }
          if (!_this.pipes[uuid]) {
            return endSocket(_this.sockets[uuid]);
          }
          _this.sockets[uuid][1].pipe(_this.pipes[uuid]).pipe(_this.sockets[uuid][2]).pipe(_this.sockets[uuid][0]);
          _this.sockets[uuid][1].release();
          return _this.sockets[uuid][0].resume();
        };
      })(this));
      this.createLocalServer();
      this.createRemoteServer();
    }

    _Class.prototype.accept = function(socket) {
      var uuid;
      console.info("accept " + socket.remoteAddress + ":" + socket.remotePort);
      uuid = this.id;
      this.id += 1;
      socket.pause();
      this.sockets[uuid] = [socket];
      socket.on('close', (function(_this) {
        return function() {
          console.info("close socket " + uuid);
          if (_this.sockets[uuid] != null) {
            delete _this.sockets[uuid];
          }
          if (_this.waits[uuid] != null) {
            return delete _this.waits[uuid];
          }
        };
      })(this));
      socket.on('error', console.error);
      return this.dataEvent.emit('accept', uuid);
    };

    _Class.prototype.createRemoteServer = function() {
      this.remoteServer = Net.createServer((function(_this) {
        return function(socket) {
          return _this.accept(socket);
        };
      })(this));
      this.remoteServer.on('error', console.error);
      return this.remoteServer.listen(this.remoteAddress.port, this.remoteAddress.ip);
    };

    _Class.prototype.createLocalServer = function() {
      this.localServer = Net.createServer((function(_this) {
        return function(socket) {
          var connected;
          connected = false;
          socket.on('error', console.error);
          return socket.on('data', function(data) {
            var hash, op, parts, ref, transfer, uuid;
            if (!connected) {
              connected = true;
              op = data.readInt8(0);
              if (op === 1) {
                parts = (data.slice(1)).toString();
                ref = parts.split('|'), transfer = ref[0], hash = ref[1];
                if (hash.length === 0 || (_this.daemonSockets[hash] != null)) {
                  hash = UUID.v1();
                }
                if (transfer.length === 0) {
                  transfer = null;
                }
                console.info("connected " + socket.remoteAddress + ":" + socket.remotePort + " = " + hash + " " + transfer);
                _this.daemonSockets[hash] = [socket, transfer];
                socket.on('close', function() {
                  if ((hash != null) && (_this.daemonSockets[hash] != null)) {
                    return delete _this.daemonSockets[hash];
                  }
                });
                return socket.write(new Buffer(hash));
              } else if (op === 2) {
                uuid = data.readInt32LE(1);
                hash = (data.slice(5)).toString();
                if (_this.pipes[uuid] != null) {
                  return socket.end();
                }
                _this.pipes[uuid] = socket;
                socket.on('close', function() {
                  console.info("close pipe " + uuid);
                  if (_this.pipes[uuid] != null) {
                    return delete _this.pipes[uuid];
                  }
                });
                console.info("created pipe " + uuid);
                return _this.dataEvent.emit('pipe', uuid, hash);
              }
            }
          });
        };
      })(this));
      this.localServer.on('error', console.error);
      return this.localServer.listen(this.localAddress.port, this.localAddress.ip);
    };

    return _Class;

  })();

}).call(this);
