// Generated by CoffeeScript 1.10.0
(function() {
  var Event, Http, Net, ProxyStream, Request, Transform, UUID, Zlib, pregQuote,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Net = require('net');

  Event = require('events');

  Http = require('http');

  UUID = require('node-uuid');

  Request = require('request');

  Transform = (require('stream')).Transform;

  Zlib = require('zlib');

  pregQuote = function(str) {
    return str.replace(/[-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  ProxyStream = (function(superClass) {
    extend(ProxyStream, superClass);

    function ProxyStream() {
      return ProxyStream.__super__.constructor.apply(this, arguments);
    }

    ProxyStream.prototype.setFrom = function(from) {
      return this.from = new RegExp(pregQuote(from), 'ig');
    };

    ProxyStream.prototype.setTo = function(to) {
      this.to = to;
    };

    ProxyStream.prototype.setStatusCode = function(statusCode) {
      return this.res.statusCode = statusCode;
    };

    ProxyStream.prototype.setHeader = function(k, v) {
      return this.res.setHeader(k, k === 'location' ? this.replace(v) : v);
    };

    ProxyStream.prototype.pipe = function(res1) {
      this.res = res1;
      return ProxyStream.__super__.pipe.apply(this, arguments);
    };

    ProxyStream.prototype.replace = function(input) {
      var str;
      if (Buffer.isBuffer(input)) {
        str = input.toString('utf8');
        return Buffer.from(this.replace(str), 'utf8');
      } else {
        return input.replace(this.from, this.to);
      }
    };

    ProxyStream.prototype._transform = function(buff, enc, callback) {
      return callback(null, buff);
    };

    return ProxyStream;

  })(Transform);

  module.exports = (function() {
    function _Class(localAddress, remoteAddress) {
      this.localAddress = localAddress;
      this.remoteAddress = remoteAddress;
      this.id = 0;
      this.dataEvent = new Event;
      this.daemonSockets = {};
      this.sockets = {};
      this.pipes = {};
      this.dataEvent.on('pipe', (function(_this) {
        return function(uuid, hash) {
          var buff, host, method, transform, url;
          if (_this.sockets[uuid] == null) {
            return;
          }
          if (_this.pipes[uuid] == null) {
            buff = new Buffer(4);
            buff.writeInt32LE(uuid);
            if (_this.daemonSockets[hash] == null) {
              return;
            }
            console.info("request pipe " + uuid);
            return _this.daemonSockets[hash][0].write(buff);
          }
          host = _this.daemonSockets[hash][1] != null ? _this.daemonSockets[hash][1] : _this.sockets[uuid][0].headers.host;
          url = 'http://' + host + _this.sockets[uuid][0].url;
          method = _this.sockets[uuid][0].method.toLowerCase();
          transform = new ProxyStream;
          transform.setFrom(host);
          transform.setTo(_this.sockets[uuid][0].headers.host);
          Object.defineProperty(transform, 'statusCode', {
            set: transform.setStatusCode
          });
          _this.sockets[uuid][0].pipe(Request[method](url)).pipe(transform).pipe(_this.sockets[uuid][1]);
          return _this.sockets[uuid][0].resume();
        };
      })(this));
      this.createLocalServer();
      this.createRemoteServer();
    }

    _Class.prototype.accept = function(req, res, hash) {
      var uuid;
      console.info("accept " + req.headers.host + req.url);
      uuid = this.id;
      this.id += 1;
      this.sockets[uuid] = [req, res];
      res.on('close', (function(_this) {
        return function() {
          console.info("close socket " + uuid);
          if (_this.sockets[uuid] != null) {
            return delete _this.sockets[uuid];
          }
        };
      })(this));
      return this.dataEvent.emit('pipe', uuid, hash);
    };

    _Class.prototype.createRemoteServer = function() {
      this.remoteServer = Http.createServer((function(_this) {
        return function(req, res) {
          var hash;
          hash = req.headers.host.split('.')[0];
          console.log(hash);
          if (_this.daemonSockets[hash] != null) {
            return _this.accept(req, res, hash);
          } else {
            res.writeHead(404);
            return res.end('Not Found');
          }
        };
      })(this));
      return this.remoteServer.listen(this.remoteAddress.port, this.remoteAddress.ip);
    };

    _Class.prototype.createLocalServer = function() {
      this.localServer = Net.createServer((function(_this) {
        return function(socket) {
          var connected;
          connected = false;
          return socket.on('data', function(data) {
            var hash, op, parts, ref, transfer, uuid;
            if (!connected) {
              connected = true;
              op = data.readInt8(0);
              if (op === 1) {
                parts = (data.slice(1)).toString();
                ref = parts.split('|'), transfer = ref[0], hash = ref[1];
                if (hash.length === 0 || (_this.daemonSockets[hash] != null)) {
                  hash = UUID.v1();
                }
                if (transfer.length === 0) {
                  transfer = null;
                }
                console.info("connected " + socket.remoteAddress + ":" + socket.remotePort + " = " + hash + " " + transfer);
                _this.daemonSockets[hash] = [socket, transfer];
                socket.on('close', function() {
                  if ((hash != null) && (_this.daemonSockets[hash] != null)) {
                    return delete _this.daemonSockets[hash];
                  }
                });
                return socket.write(new Buffer(hash));
              } else if (op === 2) {
                uuid = data.readInt32LE(1);
                hash = (data.slice(5)).toString();
                _this.pipes[uuid] = socket;
                socket.on('close', function() {
                  console.info("close pipe " + uuid);
                  if (_this.pipes[uuid] != null) {
                    return delete _this.pipes[uuid];
                  }
                });
                console.info("created pipe " + uuid);
                return _this.dataEvent.emit('pipe', uuid, hash);
              }
            }
          });
        };
      })(this));
      return this.localServer.listen(this.localAddress.port, this.localAddress.ip);
    };

    return _Class;

  })();

}).call(this);
