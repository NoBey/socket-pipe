// Generated by CoffeeScript 1.10.0
(function() {
  var Event, Http, Net, ProxyStream, Request, Transform, UUID, Zlib, endSocket, pregQuote,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Net = require('net');

  Event = require('events');

  Http = require('http');

  UUID = require('node-uuid');

  Request = require('request');

  Transform = (require('stream')).Transform;

  Zlib = require('zlib');

  pregQuote = function(str) {
    return str.replace(/[-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  endSocket = function(socket) {
    socket.resume();
    return socket.end("HTTP/1.1 404 Not Found\r\nContent-Type: text/html;charset=UTF-8\r\n\r\nNotFound");
  };

  ProxyStream = (function(superClass) {
    extend(ProxyStream, superClass);

    function ProxyStream() {
      this.filtered = false;
      this.piped = false;
      this.buffers = [];
      ProxyStream.__super__.constructor.apply(this, arguments);
    }

    ProxyStream.prototype.setCallback = function(cb) {
      this.cb = cb;
    };

    ProxyStream.prototype.setFrom = function(from) {
      return this.from = new RegExp(pregQuote(from), 'ig');
    };

    ProxyStream.prototype.setTo = function(to) {
      this.to = to;
    };

    ProxyStream.prototype.pipe = function(stream) {
      this.stream = stream;
      this.piped = true;
      return ProxyStream.__super__.pipe.apply(this, arguments);
    };

    ProxyStream.prototype.release = function() {
      var buffer, results;
      if (this.stream != null) {
        results = [];
        while (buffer = this.buffers.shift()) {
          results.push(this.stream.write(buffer));
        }
        return results;
      }
    };

    ProxyStream.prototype.callback = function(err, buff) {
      if (this.piped) {
        return ProxyStream.__super__.callback.apply(this, arguments);
      } else {
        return this.buffers.push(buff);
      }
    };

    ProxyStream.prototype._transform = function(buff, enc, callback) {
      var body, head, matches, pos, str;
      if (!this.filtered) {
        str = enc === 'buffer' ? buff.toString('binary') : buff;
        pos = str.indexOf("\r\n\r\n");
        if (pos >= 0) {
          this.filtered = true;
          head = str.substring(0, pos);
          body = str.substring(pos);
        } else {
          head = str;
          body = '';
        }
        if ((this.from != null) && (this.to != null)) {
          head = head.replace(this.from, this.to);
        }
        if (matches = head.match(/host:\s*([^\r]+)/i)) {
          if (this.cb != null) {
            head = this.cb(matches[1], head);
          }
        }
        callback(null, Buffer.from(head + body, 'binary'));
      } else {
        callback(null, buff);
      }
      if ((buff.indexOf(-1)) >= 0) {
        return this.clear();
      }
    };

    ProxyStream.prototype.clear = function() {
      this.filtered = false;
      return this.buffers = [];
    };

    return ProxyStream;

  })(Transform);

  module.exports = (function() {
    function _Class(localAddress, remoteAddress) {
      this.localAddress = localAddress;
      this.remoteAddress = remoteAddress;
      this.id = 0;
      this.dataEvent = new Event;
      this.daemonSockets = {};
      this.sockets = {};
      this.pipes = {};
      this.dataEvent.on('accept', (function(_this) {
        return function(uuid) {
          var input;
          if (_this.sockets[uuid] == null) {
            return;
          }
          input = new ProxyStream;
          _this.sockets[uuid].push(input);
          input.setCallback(function(reqHost, head) {
            var buff, hash, host, output, regex;
            console.info("request " + reqHost);
            hash = reqHost.split('.')[0];
            if (_this.daemonSockets[hash] == null) {
              return endSocket(_this.sockets[uuid][0]);
            }
            host = _this.daemonSockets[hash][1] != null ? _this.daemonSockets[hash][1] : reqHost;
            buff = new Buffer(4);
            buff.writeInt32LE(uuid);
            console.info("request pipe " + uuid);
            _this.daemonSockets[hash][0].write(buff);
            setTimeout(function() {
              if ((_this.pipes[uuid] == null) && (_this.sockets[uuid] != null) && (_this.daemonSockets[hash] != null)) {
                _this.daemonSockets[hash][0].write(buff);
                return console.info("retry pipe " + uuid);
              }
            }, 2000);
            regex = new RegExp(pregQuote(reqHost), 'ig');
            output = new ProxyStream;
            output.setFrom(host);
            output.setTo(reqHost);
            _this.sockets[uuid].push(output);
            _this.sockets[uuid][0].pause();
            return head.replace(regex, host);
          });
          _this.sockets[uuid][0].pipe(input);
          return _this.sockets[uuid][0].resume();
        };
      })(this));
      this.dataEvent.on('pipe', (function(_this) {
        return function(uuid, hash) {
          if (!_this.sockets[uuid]) {
            return;
          }
          if (!_this.daemonSockets[hash]) {
            return endSocket(_this.sockets[uuid]);
          }
          if (!_this.pipes[uuid]) {
            return endSocket(_this.sockets[uuid]);
          }
          _this.sockets[uuid][1].pipe(_this.pipes[uuid]).pipe(_this.sockets[uuid][2]).pipe(_this.sockets[uuid][0]);
          _this.sockets[uuid][1].release();
          return _this.sockets[uuid][0].resume();
        };
      })(this));
      this.createLocalServer();
      this.createRemoteServer();
    }

    _Class.prototype.accept = function(socket) {
      var uuid;
      console.info("accept " + socket.remoteAddress + ":" + socket.remotePort);
      uuid = this.id;
      this.id += 1;
      socket.pause();
      this.sockets[uuid] = [socket];
      socket.on('close', (function(_this) {
        return function() {
          console.info("close socket " + uuid);
          if (_this.sockets[uuid] != null) {
            return delete _this.sockets[uuid];
          }
        };
      })(this));
      socket.on('error', console.error);
      return this.dataEvent.emit('accept', uuid);
    };

    _Class.prototype.createRemoteServer = function() {
      this.remoteServer = Net.createServer((function(_this) {
        return function(socket) {
          return _this.accept(socket);
        };
      })(this));
      this.remoteServer.on('error', console.error);
      return this.remoteServer.listen(this.remoteAddress.port, this.remoteAddress.ip);
    };

    _Class.prototype.createLocalServer = function() {
      this.localServer = Net.createServer((function(_this) {
        return function(socket) {
          var connected;
          connected = false;
          socket.on('error', console.error);
          return socket.on('data', function(data) {
            var hash, op, parts, ref, transfer, uuid;
            if (!connected) {
              connected = true;
              op = data.readInt8(0);
              if (op === 1) {
                parts = (data.slice(1)).toString();
                ref = parts.split('|'), transfer = ref[0], hash = ref[1];
                if (hash.length === 0 || (_this.daemonSockets[hash] != null)) {
                  hash = UUID.v1();
                }
                if (transfer.length === 0) {
                  transfer = null;
                }
                console.info("connected " + socket.remoteAddress + ":" + socket.remotePort + " = " + hash + " " + transfer);
                _this.daemonSockets[hash] = [socket, transfer];
                socket.on('close', function() {
                  if ((hash != null) && (_this.daemonSockets[hash] != null)) {
                    return delete _this.daemonSockets[hash];
                  }
                });
                return socket.write(new Buffer(hash));
              } else if (op === 2) {
                uuid = data.readInt32LE(1);
                hash = (data.slice(5)).toString();
                if (_this.pipes[uuid] != null) {
                  return socket.end();
                }
                _this.pipes[uuid] = socket;
                socket.on('close', function() {
                  console.info("close pipe " + uuid);
                  if (_this.pipes[uuid] != null) {
                    return delete _this.pipes[uuid];
                  }
                });
                console.info("created pipe " + uuid);
                return _this.dataEvent.emit('pipe', uuid, hash);
              }
            }
          });
        };
      })(this));
      this.localServer.on('error', console.error);
      return this.localServer.listen(this.localAddress.port, this.localAddress.ip);
    };

    return _Class;

  })();

}).call(this);
